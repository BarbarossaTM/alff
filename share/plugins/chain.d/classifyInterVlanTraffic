#!/usr/bin/perl -w
#
# classifyInterVlanTraffic
#
# Maximilian Wilhelm <max@rfc2324.org>
#  -- Wed, 26 Apr 2006 18:08:15 +0200
#

use strict;
use Alff::Main;
use Alff::Config;

##
# Some paths
my $configfile = "/etc/alff/alff.conf";
my $rules_d = "/etc/alff/rules.d";

##
# Debugging
#
# Print out debug outbut
my $debug = 0;

# Storage for parse configuraton
my $alff = Alff::Main->new( debug => $debug );
my $config = Alff::Config->new( configfile => $configfile, debug => $debug )
	or die "Error: could not load configuration from $configfile\n";

# List of all known vlans
my @vlans;

my $default_chain_policy = $config->getDefaultChainPolicy;


################################################################################
#			    Some nifty functions			       #
################################################################################

##
# classifyTraffic from $src_vlan to $dst_vlan
sub classifyTrafficFromTo($$) { #{{{
	my $src_vlan = shift;
	my $dst_vlan = shift;

	my $chain = $src_vlan . "_to_" . $dst_vlan;

	# Try to get interface names
	my $src_interface = $config->getVlanInterface( $src_vlan );
	my $dst_interface = $config->getVlanInterface( $dst_vlan );

	# There might be multiple CIDR networks which describe a vlan...
	# It´s no risk to asume this everytime.
	my @src_networks = $config->getVlanNetworks( $src_vlan );
	my @dst_networks = $config->getVlanNetworks( $dst_vlan );

	# Not that good runtime(?), but...
	foreach my $src_network ( @src_networks ) {
		foreach my $dst_network ( @dst_networks ) {

			$alff->create_chain( $chain );

			# Build up the command line
			my $commandline = "iptables -A FORWARD -s $src_network ";

			if ( $config->getOption( "fw_type" ) eq "router" ) {
				$commandline .= " -i $src_interface " if ( $src_interface );
				$commandline .= " -o $dst_interface " if ( $dst_interface );
			}	
			elsif( $config->getOption( "fw_type" ) eq "bridge" ) {
				if ( $src_interface || $dst_interface ) {
					$commandline .= " -m physdev ";
					$commandline .= " --physdev-in $src_interface " if ( $src_interface );
					$commandline .= " --physdev-out $dst_interface " if ( $dst_interface );
				}
				$commandline .= " -m mark --mark $src_vlan ";
			}

			$commandline .= " -d $dst_network -j $chain";

			$alff->write_cmd( $commandline );
		}
	}

} #}}}

##
# Load user defined rules into the chain for the given vlans if specified in rules.d/,
# set $default_chain_policy else.
sub loadChainRules($$) { # {{{
	my $src_vlan = shift;
	my $dst_vlan = shift;
	my $chain = $src_vlan . "_to_" . $dst_vlan;

	my $rules_file;

	if ( -d $rules_d ) {
		# Configuration for exactly this chain
		if ( -f "$rules_d/$chain" ) {
			$rules_file = "$rules_d/$chain";
			if ( ! $alff->write_filecontent( $rules_file ) ) {
				print STDERR "INFO: Setting the default_chain_policy for chain $chain\n";
				$alff->write_cmd( "iptables -A $chain -j $default_chain_policy" );
			}

			print STDERR "Found and loaded rules file $rules_file\n" if ( $debug );

		# defaulted configuration which fits to this chains
		} else {
			print STDERR "No explicit configuration found for chain $chain, lookin for a default config fitting to this vlan... " if ( $debug );

			if ( -f "$rules_d/$src_vlan" . "_to_default" ) {
				$rules_file = "$rules_d/$src_vlan" . "_to_default";

			} elsif ( -f "default_to_" . "$rules_d/$dst_vlan" ) {
				$rules_file = "default_to_" . "$rules_d/$dst_vlan";
			}

			if ( $rules_file ) {
				print STDERR "found one at $rules_file...\n" if ( $debug );

				if ( open ( RULES, "<$rules_file" ) ) {
					while ( <RULES> ) {
						# skip comments and empty lines
						next if ( m/^#|^$/ );

						# replace 'default' with the current chain
						s/default_/${src_vlan}_/;
						s/_default/_${dst_vlan}/;

						$alff->write_cmd( $_ );
					}
					close( RULES );
				} else {
					print STDERR "Error while loading rules from $rules_file, setting default_chain_policy for chain $chain\n";
					$alff->write_cmd( "iptables -A $chain -j $default_chain_policy" );
				}
			} else {
				print "nothing found, use default_chain_policy.\n" if ( $debug );
				$alff->write_cmd( "iptables -A $chain -j $default_chain_policy" );
				
			}
		}
	} else {
		$alff->write_cmd( "iptables -A $chain -j $default_chain_policy" );
	}
} #}}}


################################################################################
#				Let´s go				       #
################################################################################

##
# Get a list of all known vlan ids
@vlans = $config->getVlanList;

##
# Loop through all combinations of vlans and generate a vlan-matrix
# (Skip x <-> x rules and rules for x <-> y for x,y \in unfiltered vlans
#
print " * Classifying inter vlan traffic... ";
foreach my $src_vlan ( @vlans ) {

	print ".";
	foreach my $dst_vlan ( @vlans ) {
		# Skip x <-> x rules.
		if ( $src_vlan eq $dst_vlan ) {
			next;
		}

		# If both vlans are *not* behind this firewall, there is nothing we could
		# do for them...
		if ( ! $config->isFilteredVlan( $src_vlan ) and ! $config->isFilteredVlan( $dst_vlan ) ) {
			next;
		}

		# Ok, just do it[tm]
		classifyTrafficFromTo( $src_vlan, $dst_vlan );
		loadChainRules( $src_vlan, $dst_vlan );
	}
}
print " done.\n";

# vim:foldmethod=marker
