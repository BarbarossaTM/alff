#!/usr/bin/perl -w
#
# classifyInterVlanTraffic
#
# Maximilian Wilhelm <max@rfc2324.org>
#  -- Wed, 26 Apr 2006 18:08:15 +0200
#

use strict;
use Alff::Config;
use Alff::Main;

my $VERSION = 1.0;

my $plugin_name = 'classifyInterVlanTraffic';

# Debugging
my $debug = 0;

# Create instances of used objects
my $alff = Alff::Main->new( debug => $debug );
my $config = Alff::Config->new( debug => $debug )
	or die "Error: could not load configuration.\n";

##
# Some paths
my $config_dir = $config->getConfigDir();
my $rules_d = "$config_dir/rules.d";

# List of all known vlans
my @vlans = $config->getVlanList;

# The target to put into totally unconfigured chains
my $default_chain_target = $config->getPluginOption( $plugin_name, "default_chain_target" ) || "REJECT";
my $remove_empty_chains  = $config->getPluginOption( $plugin_name, "remove_empty_chains" )  || 0;
my $force_x_to_x_chains  = $config->getPluginOption( $plugin_name, "force_x_to_x_chains" )  || 0;

################################################################################
#			    Some nifty functions			       #
################################################################################

##
# classifyTraffic from $src_vlan to $dst_vlan
sub classifyTrafficFromTo($$) { #{{{
	my $src_vlan = shift;
	my $dst_vlan = shift;

	my $chain = $src_vlan . "_to_" . $dst_vlan;

	# Try to get interface names
	my @src_interfaces = $config->getVlanInterfaces( $src_vlan );
	my @dst_interfaces = $config->getVlanInterfaces( $dst_vlan );
	
	# There might be multiple CIDR networks which describe a vlan...
	# It´s no risk to asume this everytime.
	my @src_networks = $config->getVlanNetworks( $src_vlan );
	my @dst_networks = $config->getVlanNetworks( $dst_vlan );

	# Create the chain for this network transition
	$alff->create_chain( $chain );

	# Not that good runtime(?), but...
	foreach my $src_network ( @src_networks ) {
		my $src_network_version = $alff->getIpVersion($src_network);
		foreach my $dst_network ( @dst_networks ) {
			if($src_network_version == $alff->getIpVersion($dst_network)) {
				foreach my $dst_interface ( @dst_interfaces ) {
					# create backup of dst and src network
					my $src_network_bak = $src_network;
					my $dst_network_bak = $dst_network;

					foreach my $src_interface ( @src_interfaces ) {

						# Build up the command line
						my $commandline = "";
						if($src_network_version == 4) {
							$commandline .= "iptables -A FORWARD ";
						} elsif($src_network_version == 6) {
							$commandline .= "ip6tables -A FORWARD ";
						} else {
							$commandline .= "# $src_network isn't a known network ";
						}
			
						if ($src_network =~ m/!/) {
								$src_network =~ s/!//;
								$commandline .= " ! ";
						}
						$commandline .= " -s $src_network ";
			
						if ( $config->getOption( "fw_type" ) eq "router" ) {
							$commandline .= " -i $src_interface " if ( $src_interface );
							$commandline .= " -o $dst_interface " if ( $dst_interface );
						}	
						elsif( $config->getOption( "fw_type" ) eq "bridge" ) {
							if ( $src_interface || $dst_interface ) {
								$commandline .= " -m physdev ";
								$commandline .= " --physdev-in $src_interface " if ( $src_interface );
								$commandline .= " --physdev-out $dst_interface " if ( $dst_interface );
							}
							$commandline .= " -m mark --mark $src_vlan ";
						}
			
						if ($dst_network =~ m/!/) {
							$dst_network =~ s/!//;
							$commandline .= " ! ";
						}
						$commandline .= " -d $dst_network -j $chain";
			
						$alff->write_line( $commandline );

						# restore old networks
						$src_network = $src_network_bak;
						$dst_network = $dst_network_bak;

					}
				}
			}
		}
	}

} #}}}

##
# Load user defined rules into the chain for the given vlans if specified in rules.d/,
# set $default_chain_target else.
sub loadChainRules($$) { # {{{
	my $src_vlan = shift;
	my $dst_vlan = shift;
	my $chain = $src_vlan . "_to_" . $dst_vlan;

	##
	# Load default rules from the following files in this order
	my @default_files = (  "${src_vlan}_to_default", "default_to_${dst_vlan}" );
	# How many files have been loaded?
	my $load_count = 0;
	
	for my $default_file ( @default_files ) {
		# Prepend path of rules.d/
		$default_file = "$rules_d/$default_file";

		if ( -f "$default_file" ) {
			if ( open ( RULES, "<$default_file" ) ) {
				while ( <RULES> ) {
					# skip comments and empty lines
					next if ( m/^#|^$/ );

					# replace 'default' with the current chain
					s/default_/${src_vlan}_/;
					s/_default/_${dst_vlan}/;

					chomp;

					$alff->write_line( $_ );
				}
				close( RULES );

				print STDERR "INFO: Found and loaded default rules for chain $chain from $default_file\n" if ( $debug );
				$load_count++;
			} else {
				print STDERR "Error: Could not load default rules for chain $chain from $default_file\n";
			}
		}
	}

	##
	# Load explicit chain configuration
	if ( -f "$rules_d/$chain" ) {
		my $rules_file = "$rules_d/$chain";
		if (  $alff->write_filecontent( $rules_file ) ) {
			print STDERR "INFO: Found and loaded rules file $rules_file\n" if ( $debug );
			$load_count++;
		} else {
			print STDERR "ERROR: Could not load chain rules for chain $rules_file\n";
		}
	}

	if ( $load_count == 0 ) {
		print STDERR "INFO: No rules found for chain $chain, setting the default_chain_target...\n" if ( $debug );
		$alff->write_line( "iptables -A $chain -j $default_chain_target" );
		$alff->write_line( "ip6tables -A $chain -j $default_chain_target" );
	}
} #}}}

##
# Check if there are any rules specified for this chain
sub hasRules($$) { #{{{
	my $src_vlan = shift;
	my $dst_vlan = shift;
	my $chain = $src_vlan . "_to_" . $dst_vlan;

	my @files = ( "${src_vlan}_to_default", "default_to_${dst_vlan}", "${src_vlan}_to_${dst_vlan}" );

	# If there is no rules.d/ there are surely no files
	return 0 if ( ! -d "$rules_d" );

	foreach my $file ( @files ) {
		# Ok found one
		return 1 if ( -f "$rules_d/$file" );
	}

	# Nothing there
	return 0;
} #}}}

################################################################################
#				Let´s go				       #
################################################################################

##
# Loop through all combinations of vlans and generate a vlan-matrix
# (Skip x <-> x rules and rules for x <-> y for x,y \in unfiltered vlans
#
print " * Classifying inter vlan traffic... ";

if ( ! -d "$rules_d" ) {
	print STDERR "Error: rules.d directory \"${rules_d}\" does not exist.\n";
	print STDERR "You might want to fix this.\n";
	exit 1;
}

foreach my $src_vlan ( @vlans ) {

	print ".";
	foreach my $dst_vlan ( @vlans ) {
		# Skip x <-> x rules (if not forced otherwise)
		if ( $src_vlan eq $dst_vlan and $force_x_to_x_chains ne "yes" ) {
			next;
		}

		# If both vlans are *not* behind this firewall, there is nothing we could do for them...
		if ( ! $config->isFilteredVlan( $src_vlan ) and ! $config->isFilteredVlan( $dst_vlan ) ) {
			next;
		}

		# Skip this traversal if we should watch for empty chains and there are no rules
		if ( $remove_empty_chains eq "yes" and ! hasRules( $src_vlan, $dst_vlan ) ) {
			next;
		}

		# OK, just do it[tm]
		classifyTrafficFromTo( $src_vlan, $dst_vlan );
		loadChainRules( $src_vlan, $dst_vlan );
		# create empty line after each network traversal in rules file
		$alff->write_line(" ");
	}
}
print " done.\n";

# vim:foldmethod=marker
