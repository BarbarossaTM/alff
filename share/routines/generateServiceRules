#!/bin/sh
#
# Generate chain for the given service and place server/port rules into
# the new chain. Read the configuration from 'services.d'
#
# Maximlian Wilhelm <mwilhelm@math.uni-paderborn.de>
# Joerg Jungermann <joju@math.uni-paderborn.de>
#  -- Tue, 06 Dec 2005 17:48:00 +0100
#
# Updated by Maximilian Wilhelm <max@rfc2324.org>
#  -- Thu, 27 Apr 2006 21:24:01 +0200
#

SERVICES_D="/etc/alff/services.d"

# In case of trouble, at least, create the chain, or flush it,
# if already existing
#cleanup() {
#	# If there is trouble before getting the service name, do nothing
#	if [ "${CHAIN}" ]; then
#		"${CHAIND_PLUGIN_DIR}/create_chain_" ${CHAIN}
#	fi
#}
#
#set -e
#trap cleanup 1 2 15 EXIT 


if [ -z "$1" ]; then
	echo "Usage: $0 <servicename>" >&2
	exit 1
fi

# Create chain for this service
SERVICE="${1}"
CHAIN="allowSrv${SERVICE}"


# Check for configuration file
if [ ! -f "${SERVICES_D}/${SERVICE}" ]; then
	echo "Error: No configuration file for ${SERVICE} found!" >&2
	exit 1
fi

# Load the configuration
if ! source "${SERVICES_D}/${SERVICE}"; then
	echo "Error: Could not load configuration file for ${SERVICE}!" >&2
	exit 1
fi


##
# Check the config #{{{

# SERVERS defined in config file?
if [ -z "${SERVERS}" ]; then
	echo "Error: You need to define SERVERS in service file." >&2
	exit 1
fi

# PORTS defined in config file?
if [ -z "${PORTS}" ]; then
	echo "Error: You need to define PORTS in service file." >&2
	exit 1
fi

#}}}

"${CHAIND_PLUGIN_DIR}/create_chain_" ${CHAIN}

# Create rules matchting traffic to the servers(s) with the given port(s)
for server in ${SERVERS}; do

	for service_port in ${PORTS}; do
		# $service_port is set like "80/tcp", so we have to "crack" it.
		port="${service_port%%/*}"		# get value before /
		protocol="${service_port##*/}"		# get value after /
		
		if [ "${port}" -a "${protocol}" ]; then
			echo "iptables -A ${CHAIN} -p ${protocol} -d ${server} --dport ${port} -j ACCEPT" >&3
		else
			echo "Error: in port definition for service ${SERVICE}." >&2
			exit 1
		fi
	done
done

if [ "${ALLOW_FROM_TRUSTED_NETWORKS}" == "yes" ]; then
	echo "iptables -A allowServicesFromTrustedNets -j ${CHAIN}" >&3
fi

if [ "${ALLOW_FROM_FILTERED_NETWORKS}" == "yes" ]; then
	echo "iptables -A allowServicesFromFilteredNets -j ${CHAIN}" >&3
fi

if [ "${ALLOW_FROM_WORLD}" == "yes" ]; then
	echo "iptables -A allowWorldOpenServices -j ${CHAIN}" >&3
fi


# ##
# # Callback stuff
# if [ "${CALLBACK_DST_PORTS}" -o "${CALLBACK_SRC_PORTS}" ]; then
# 	CALLBACK_CHAIN="allowSrvCB_${SERVICE}"
# 
# 	if ! iptables -N ${CALLBACK_CHAIN} 2>/dev/null; then
# 		iptables -F ${CALLBACK_CHAIN}
# 	fi
# 
# 	for server in ${SERVERS}; do
# 
# 		for cb_dst_port in ${CALLBACK_DST_PORTS}; do
# 			# $service_port is set like "80/tcp", so we have to "crack" it.
# 			port="${cb_dst_port%%/*}"		# get value before /
# 			protocol="${cb_dst_port##*/}"		# get value after /
# 
# 			iptables -A ${CALLBACK_CHAIN} -p ${protocol} -s ${server} --dport ${port} -j ACCEPT
# 		done
# 
# 		for cb_src_port in ${CALLBACK_SRC_PORTS}; do
# 			# $service_port is set like "80/tcp", so we have to "crack" it.
# 			port="${cb_src_port%%/*}"		# get value before /
# 			protocol="${cb_src_port##*/}"		# get value after /
# 			
# 			iptables -A ${CALLBACK_CHAIN} -p ${protocol} -s ${server} --sport ${port} -j ACCEPT
# 		done
# 	done
# 
# 	if [ "${ALLOW_CALLBACK_TO_TRUSTED_NETWORKS}" == "yes" ]; then
# 		iptables -A  allowCB_SrvToTrustedNets  -j ${CALLBACK_CHAIN}
# 	fi
# fi
