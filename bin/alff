#!/bin/bash
#
# alff
#
# Main firewall management tool for the alff firewall fremawork.
#
# Maximlian Wilhelm <max@rfc2324.org>
#  -- Thu, 08 Dec 2005 18:01:52 +0100
#

# Who I am
MY_NAME="alff"

##
# alff library stuff
export ALFF_FUNCTION_DIR="/usr/share/alff/routines/"
PLUGIND_PLUGIN_DIR="/usr/share/alff/plugins/plugin.d/"

##
# Some default values
CONFIG_BASEDIR="/etc/alff"

# The config space to use if none specified
DEFAULT_CONFIG_SPACE="default"

## Some functions ##

function checkConfigDir() { # Check the configuration (environment) #{{{

	# Dereference symlink if it is one
	if [ -L "${ALFF_CONFIG_DIR}" ]; then
		ALFF_CONFIG_DIR=`readlink -e "${ALFF_CONFIG_DIR}"`
	fi

	if [ ! -d "${ALFF_CONFIG_DIR}" ]; then
		usage
		echo "Error: ALFF_CONFIG_DIR \"${ALFF_CONFIG_DIR}\" does not exist!" >&2

		# define COMPAT
		if [ "${ALFF_CONFIG_SPACE}" = 'default' ]; then
			echo "" >&2
			echo "If you are upgrading from an earlier version of alff, please move your" >&2
			echo "configuration from /etc/alff to ${CONFIG_BASEDIR}/${DEFAULT_CONFIG_SPACE}." >&2
			echo "This will make your configuration to be the 'default' config space and" >&2
			echo "you can use alff as before." >&2
		fi
		exit 1
	fi

	# There should be an alff.conf
	if [ ! -f "${ALFF_CONFIG_FILE}" ]; then
		echo "Error: There is no alff.conf in \"${ALFF_CONFIG_DIR}\".">&2
		exit 1
	fi

	# There should be a plugin.d directory
	if [ ! -d "${PLUGIN_D}" ]; then
		usage
		echo "Error: Plugin directory \"${PLUGIN_D}\" does not exist!" >&2
		exit 1
	fi
} #}}}

function initCacheDirs() { # Initialize the cache directories #{{{
	for table in \. filter mangle nat raw; do
		if [ ! -d "${ALFF_CACHE_DIR_CHAINS}/${table}" ]; then
			mkdir -p "${ALFF_CACHE_DIR_CHAINS}/${table}"
		fi
	done

	if [ ! -d "${CACHE_DIR_BUILD}" ]; then
		mkdir -p "${CACHE_DIR_BUILD}"
	fi
} #}}}

function checkTools() { # check for needed tooles #{{{
	for tool in awk find grep sh; do
		if ! command -v ${tool} >/dev/null 2>/dev/null; then
			echo "Error: \"${tool}\" is needed by ${MY_NAME}, but was not found on your system." >&2
		fi
	done
} #}}}

function usage() { # print usage #{{{
	echo "Usage: ${MY_NAME} [ -c config_space ] { generate | push | -list | <function> [ <param> ] }"
	echo ""
	echo "${MY_NAME} is the main firewall management tool."
	echo "It is used for generating rulesets, pushing rulesets to your firewalls"
	echo "Alff´s functions may be usefull for changing the configuration."
	echo "See 'alff -list' for a list of all available functions."
	echo ""
	echo "We assume that you know what you are doing..."
	echo ""
} #}}}

function list_functions() { # list available functions #{{{
	echo "Functions supported by ${MY_NAME}:"
	find "${ALFF_FUNCTION_DIR}" -maxdepth 1 -type f -exec "${ALFF_FUNCTION_DIR}/build-in/show-function-info" {} \;
} #}}}

function exec_function() { # execute given function #{{{
	local function_name="${1}"
	if [ -f "${ALFF_FUNCTION_DIR}/${function_name}" ]; then
		# shift function name away and keep possbile arguments
		shift
		"${ALFF_FUNCTION_DIR}/${function_name}" $@
	else
		usage
		echo ""
		echo "ERROR: There is no function \"${function_name}\"!" >&2
		exit 1
	fi

} #}}}

function exec_buildin_function() { # execute given function #{{{
	local function_name="${1}"
	if [ -f "${ALFF_FUNCTION_DIR}/build-in/${function_name}" ]; then
		# shift function name away and keep possbile arguments
		shift
		"${ALFF_FUNCTION_DIR}/build-in/${function_name}" $@
	else
		echo "ERROR: There is no build-in function \"${function_name}\"!" >&2
		exit 1
	fi
} #}}}

# Preload definitions from file (rich mans source) #{{{
function preload()
{
	if [ "${1}" ]; then
		if [ -f ${1} -a -r ${1} ]; then
			source ${1}
			if [ ! $? ]; then
				echo "Failed to preload file \"${1}\", exiting." >&2
				exit 1
			fi
		else
			echo "Unable to preload file \"${1}\". File does not exist or is not accessable, exiting." >&2
			exit 1;
		fi
	else
		echo "preload: parameter missing. Exiting, to be save..."
		exit 1
	fi
} #}}}

##
# Set $ALFF_CONFIG_SPACE to the given value.
function setConfigSpace() { #{{{

	ALFF_CONFIG_SPACE="${1}"

	##
	# Configuration stuff
	export ALFF_CONFIG_SPACE
	export ALFF_CONFIG_DIR="${CONFIG_BASEDIR}/${ALFF_CONFIG_SPACE}"
	export ALFF_CONFIG_FILE="${ALFF_CONFIG_DIR}/alff.conf"
	# exported for buildin-routine execte-plugin
	export PLUGIN_D="${ALFF_CONFIG_DIR}/plugin.d"

	##
	# Some caches used at runtime
	export CACHE_BASEDIR="/var/cache/alff/${ALFF_CONFIG_SPACE}"
	export CACHE_DIR_BUILD="${CACHE_BASEDIR}/ruleset.build"
	export ALFF_CACHE_DIR_CHAINS="${CACHE_BASEDIR}/chains"
	CURRENT_RULESET="${CACHE_BASEDIR}/alff.rules"
} #}}}


## Showtime ##

setConfigSpace "default"

checkTools

preload "/usr/share/alff/lib/routines"

# Loop over $1 to figure out what to do
while [ "$1" ]; do
	case "$1" in 
		-c) # Use given config space {{{
			setConfigSpace $2
			shift 2
			;;
			#}}}

		-h|--help) # Print usage text {{{
			usage
			exit 0
			;;
			#}}}

		-list) # List available functions {{{
			list_functions
			exit 0
			;;
			#}}}

		generate) # Generate ruleset {{{
			echo "The ALFF Linux Firewall Framework awakes ..."
			echo "Using config space ${ALFF_CONFIG_SPACE}."
			echo ""

			checkConfigDir
			initCacheDirs

			echo -n  "Cleaning up cache dirs... "
			for dir in "${ALFF_CACHE_DIR_CHAINS}" "${CACHE_DIR_BUILD}"; do
				if [ `dirname "${dir}"` != "${CACHE_BASEDIR}" ]; then
					echo "ERROR: Should cleanup cache dir not in ${CACHE_BASEDIR}" >&2
					exit 1
				fi

				find "${dir}" -type f -exec rm {} \;		&& echo -n "`basename ${dir}` "
			done
			echo "done."
			echo ""

			# Run pregenerate hooks
			if ! executeHooks pregenerate; then
				echo "Errors while executing pregenerate hooks, exiting!" >&2
				exit 1
			fi

			# FIXME: Need concept of putting shell commands to the firewall machines.
			# Maybe as prefix to the iptables-restore rules?
			echo ""
			echo ""
			configureFirewallNetworkOptions 3> "${CACHE_DIR_BUILD}/000_proc_options"
			echo ""

			echo "Generating rules... "
			##
			# pimp my "run-parts"
			#
			# Create fd3 (all script should output there stuff to fd3, which is redirected to a proper outfile
			exec 3>&1

			if !  find "${PLUGIN_D}"  \( -type l -or -type f \) -exec basename {} \; | sort -n | while read plugin; do	
					if [ -x "${PLUGIN_D}/${plugin}" ]; then
						if ! "${ALFF_FUNCTION_DIR}/build-in/execute-plugin" "${plugin}"; then
							echo "" >&2
							echo "There occured errors while executing plugin ${plugin}." >&2
							echo "Alff will stop rule generation now to avoid trouble." >&2
							exit 1
						fi
					fi
				done ; then
					# Second exit to stop the 'whole' alff. (remind the "| while" does open a subshell.)
					exit 1
			fi


			exec_buildin_function loadUserRules 3> "${CACHE_DIR_BUILD}/999_user_rules"

			echo ""
			echo "Generating ruleset... "
			cat "${CACHE_DIR_BUILD}"/* > "${CURRENT_RULESET}"

			if ! executeHooks postgenerate; then
				echo "Errors while executing postgenerate hooks, exiting!" >&2
				exit 1
			fi

			exit 0
			;;
			#}}}

		push) # Push ruleset to firewall machine(s) {{{
			echo "The ALFF Linux Firewall Framework awakes ..."
			echo "Using config space ${ALFF_CONFIG_SPACE}."
			echo ""

			checkConfigDir
			initCacheDirs

			if [ ! -s "${CURRENT_RULESET}" ]; then
				echo "Error: There are no rules to push, staying cool" >&2
				exit 1
			fi

			if ! executeHooks prepush; then
				echo "Error while executing prepush hooks!" >&2
				exit 1
			fi

			# Maybe we got an explicit machine to push to
			if [ "${2}" ]; then
				echo -n "Pushing ruleset to ${2}: "
				exec_buildin_function push-rules "${2}" "${CURRENT_RULESET}" && echo "done." || echo "FAILED!"
				exec_buildin_function approve-rules "${2}"
			else
				MACHINE_IDS=`exec_function getMachines`
				if [ -z "${MACHINE_IDS}" ]; then
					echo "Error: You did not specify at least one machine in alff.conf." >&2
					exit 1
				fi
				
				for machine_id in ${MACHINE_IDS}; do
					echo -n "Pushing rules to ${machine_id}: "
					exec_buildin_function push-rules ${machine_id} "${CURRENT_RULESET}" && echo "done." || echo "FAILED!"
					exec_buildin_function approve-rules "${machine_id}"
					echo ""
				done
			fi

			if ! executeHooks postpush; then
				echo "Error while executing postpush hooks!" >&2
				exit 1
			fi

			exit 0
			;;
			#}}}

		*) # If $1 is a function, execute it {{{
			if [ $# -gt 0 ]; then
				checkConfigDir
				initCacheDirs

				# try to run former $1
				exec_function ${@}

				exit 0
			else
				usage
				exit 1
			fi
			;;
			#}}}
	esac
done

# vim:ft=sh:foldmethod=marker:
