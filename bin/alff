#!/usr/bin/env sh
#
# alff
#
# Main firewall management tool for the alff firewall fremawork.
#
# Maximlian Wilhelm <max@rfc2324.org>
#  -- Thu, 08 Dec 2005 18:01:52 +0100
#

##
# Configuration stuff
CONFIG_FILE="/etc/alff/alff.conf"
CONFIG_DIR="/etc/alff"
PLUGIN_D="${CONFIG_DIR}/plugin.d"

##
# alf library stuff
export ALFF_FUNCTION_DIR="/usr/share/alff/routines/"
PLUGIND_PLUGIN_DIR="/usr/share/alff/plugins/plugin.d/"

##
# Some caches used at runtime
CACHE_DIR="/var/cache/alff/"
CACHE_DIR_BUILD="${CACHE_DIR}/ruleset.build"
CACHE_DIR_CHAINS="${CACHE_DIR}/chains"
CURRENT_RULESET="${CACHE_DIR}/alff.rules"

MY_NAME="alff"

## Some functions ##

function checkConfigDir() { # Check the configuration (environment) #{{{
	if [ ! -d "${CONFIG_DIR}" ]; then
		echo "Error: CONFIG_DIR \"${CONFIG_DIR}\" does not exist!" >&2
		exit 1
	fi

	if [ ! -d "${PLUGIN_D}" ]; then
		echo "Error: CONFIG_DIR \"${PLUGIN_D}\" does not exist!" >&2
		exit 1
	fi

	for dir in \. filter mangle nat; do
		if [ ! -d "${CACHE_DIR_CHAINS}/${dir}" ]; then
			mkdir -p "${CACHE_DIR_CHAINS}/${dir}"
		fi
	done

	if [ ! -d "${CACHE_DIR_BUILD}" ]; then
		mkdir -p "${CACHE_DIR_BUILD}"
	fi
} #}}}

function checkTools() { # check for needed tooles #{{{
	for tool in awk find grep sh; do
		if ! command -v ${tool} >/dev/null 2>/dev/null; then
			echo "Error: \"${tool}\" is needed by ${MY_NAME}, but was not found on your system." >&2
		fi
	done
} #}}}

function usage() { # print usage #{{{
	echo "Usage: ${MY_NAME} { generate | push | -list | <function> [ <param> ] }"
	echo ""
	echo "${MY_NAME} is the main firewall management tool."
	echo "It is used for generating rulesets, pushing rulesets to your firewalls"
	echo "Alff´s functions may be usefull for changing the configuration."
	echo "See 'alff -list' for a list of all available functions."
	echo ""
	echo "We assume that you know what you are doing..."
} #}}}

function list_functions() { # list available functions #{{{
	echo "Functions supported by ${MY_NAME}:"
	find "${ALFF_FUNCTION_DIR}" -maxdepth 1 -type f -exec "$ALFF_FUNCTION_DIR}/build-in/show-function-info" {} \;
} #}}}

function exec_function() { # execute given function #{{{
	local function_name="${1}"
	if [ -f "${ALFF_FUNCTION_DIR}/${function_name}" ]; then
		# shift function name away and keep possbile arguments
		shift
		"${ALFF_FUNCTION_DIR}/${function_name}" $@
	else
		usage
		echo ""
		echo "ERROR: There is no function \"${function_name}\"!" >&2
		exit 1
	fi

} #}}}

function exec_buildin_function() { # execute given function #{{{
	local function_name="${1}"
	if [ -f "${ALFF_FUNCTION_DIR}/build-in/${function_name}" ]; then
		# shift function name away and keep possbile arguments
		shift
		"${ALFF_FUNCTION_DIR}/build-in/${function_name}" $@
	else
		echo "ERROR: There is no build-in function \"${function_name}\"!" >&2
		exit 1
	fi
} #}}}

# Preload definitions from file (rich mans source) #{{{
function preload()
{
	if [ "${1}" ]; then
		if [ -f ${1} -a -r ${1} ]; then
			source ${1}
			if [ ! $? ]; then
				echo "Failed to preload file \"${1}\", exiting." >&2
				exit 1
			fi
		else
			echo "Unable to preload file \"${1}\". File does not exist or is not accessable, exiting." >&2
			exit 1;
		fi
	else
		echo "preload: parameter missing. Exiting, to be save..."
		exit 1
	fi
} #}}}

## Showtime ##

checkConfigDir
checkTools

preload "/usr/share/alff/lib/routines"

case "$1" in 
	-h|--help) #{{{
		usage
		exit 0
		;;
		#}}}

	-list) #{{{
		list_functions
		exit 0
		;;
		#}}}

	generate) #{{{
		echo "The ALFF Linux Firewall Framework awakes ..."
		echo ""

		echo -n  "Cleaning up cache dirs... "
		find "${CACHE_DIR}/chains/" -type f -exec rm {} \;	&& echo -n "chains "
		find "${CACHE_DIR_BUILD}" -type f -exec rm {} \;	&& echo -n "`basename ${CACHE_DIR_BUILD}` "
		echo "done."
		echo ""

		# Run pregenerate hooks
		if ! executeHooks pregenerate; then
			echo "Errors while executing pregenerate hooks, exiting!" >&2
			exit 1
		fi

		echo ""
		echo ""
 		configureFirewallNetworkOptions 3> "${CACHE_DIR_BUILD}/000_proc_options"
		echo ""

		echo "Generating rules... "
		##
		# pimp my "run-parts"
		#
		# Create fd3 (all script should output there stuff to fd3, which is redirected to a proper outfile
		exec 3>&1
		# export environment variables which will be used by the plugins
		export PLUGIND_PLUGIN_DIR
		export CACHE_DIR_CHAINS
		if !  find "${PLUGIN_D}"  \( -type l -or -type f \) -exec basename {} \; | sort -n | while read plugin; do	
				if [ -x "${PLUGIN_D}/${plugin}" ]; then
					if ! sh -c "${PLUGIN_D}/${plugin}" 3> "${CACHE_DIR_BUILD}/${plugin}"; then
						echo "" >&2
						echo "There occured errors while executing plugin ${plugin}." >&2
						echo "Alff will stop rule generation now to avoid trouble." >&2
						exit 1
					fi
				fi
			done ; then
				# Second exit to stop the 'whole' alff. (remind the "| while" does open a subshell.)
				exit 1
		fi
			

		"$0" loadUserRules 3> "${CACHE_DIR_BUILD}/999_user_rules"

		echo ""
		echo "Generating ruleset... "
		cat "${CACHE_DIR_BUILD}"/* > "${CURRENT_RULESET}"

		if ! executeHooks postgenerate; then
			echo "Errors while executing postgenerate hooks, exiting!" >&2
			exit 1
		fi
		
		;;
		#}}}

	push) #{{{
		echo "The ALFF Linux Firewall Framework awakes ..."
		echo ""

		if [ ! -s "${CURRENT_RULESET}" ]; then
			echo "Error: There are no rules to push, staying cool" >&2
			exit 1
		fi

		if ! executeHooks prepush; then
			echo "Error while executing prepush hooks!" >&2
			exit 1
		fi

		# Maybe we got an explicit machine to push to
		if [ "${2}" ]; then
			echo -n "Pushing ruleset to ${2}: "
			exec_buildin_function push-rules "${2}" "${CURRENT_RULESET}" && echo "done." || echo "FAILED!"
			exec_buildin_function approve-rules "${2}"
		else
			MACHINE_IDS=`alff getMachines`
			if [ -z "${MACHINE_IDS}" ]; then
				echo "Error: You did not specify at least one machine in alff.conf." >&2
				exit 1
			fi
			
			for machine_id in ${MACHINE_IDS}; do
				echo -n "Pushing rules to ${machine_id}: "
				exec_buildin_function push-rules ${machine_id} "${CURRENT_RULESET}" && echo "done." || echo "FAILED!"
				exec_buildin_function approve-rules "${machine_id}"
				echo ""
			done
		fi

		if ! executeHooks postpush; then
			echo "Error while executing postpush hooks!" >&2
			exit 1
		fi
		
		;;
		#}}}

	*) #{{{
		if [ $# -gt 0 ]; then
			# try to run former $1
			exec_function ${@}
		else
			usage
			exit 1
		fi
		;;
		#}}}
esac

# vim:ft=sh:foldmethod=marker:
