#!/usr/bin/env sh
#
# alff
#
# Main firewall management tool for the alff firewall fremawork.
#
# Maximlian Wilhelm <mwilhelm@math.uni-paderborn.de>
#  -- Thu, 08 Dec 2005 18:01:52 +0100
#

FUNCTION_DIR="/usr/share/alff/routines/"

CHAIND_PLUGIN_DIR="/usr/share/alff/plugins/chain.d/"

##
# Some caches used at runtime
CACHE_DIR="/var/cache/alff/"
CACHE_DIR_BUILD="${CACHE_DIR}/ruleset.build"
CACHE_DIR_CHAINS="${CACHE_DIR}/chains"

CONFIG_FILE="/etc/alff/alff.conf"
CONFIG_DIR="/etc/alff"
CHAIN_D="${CONFIG_DIR}/chain.d"


MY_NAME="alff"

## Some functions ##

function checkConfigDir() { # Check the configuration (environment) #{{{
	if [ ! -d "${CONFIG_DIR}" ]; then
		echo "Error: CONFIG_DIR \"${CONFIG_DIR}\" does not exist!" >&2
		exit 1
	fi

	if [ ! -d "${CHAIN_D}" ]; then
		echo "Error: CONFIG_DIR \"${CHAIN_D}\" does not exist!" >&2
		exit 1
	fi
} #}}}

function checkTools() { # check for needed tooles #{{{
	for tool in awk bc find grep iptables sh run-parts; do
		if ! command -v ${tool} >/dev/null 2>/dev/null; then
			echo "Error: \"${tool}\" is needed by ${MY_NAME}, but was not found on your system." >&2
		fi
	done
} #}}}

function usage() { # print usage #{{{
	echo "Usage: ${MY_NAME} { -list | start | stop | reload | restart | <function> [ <param> ] }"
	echo ""
	echo "${MY_NAME} is the main firewall management tool."
	echo "It is used for starting, stopping and reloading the firewall rules"
	echo "or add/remove services and reload the configuration after changes."
	echo ""
	echo "We assume that you know what you are doing..."
} #}}}

function list_functions() { # list available functions #{{{
	echo "Functions supported by ${MY_NAME}:"
	find "${FUNCTION_DIR}" -type f -exec basename {} \; | grep -v "^Entries$\|^Root$\|^Repository$" | sed -e 's/^/ * /'
} #}}}

function exec_function() { # execute given function #{{{
	fw_function="${1}"
	if [ -f "${FUNCTION_DIR}/${fw_function}" ]; then
		# shift function name away and keep possbile arguments
		shift
		"${FUNCTION_DIR}/${fw_function}" $@
	else
		echo "Error: Function $1 does not exist." >&2
		echo "Use ${MY_NAME} -list to get a list of all implemented functions"
		exit 1
	fi

} #}}}

# Preload definitions from file (rich mans source) #{{{
function preload()
{
	if [ "${1}" ]; then
		if [ -f ${1} -a -r ${1} ]; then
			source ${1}
			if [ ! $? ]; then
				echo "Failed to preload file \"${1}\", exiting." >&2
				exit 1
			fi
		else
			echo "Unable to preload file \"${1}\". File does not exist or is not accessable, exiting." >&2
			exit 1;
		fi
	else
		echo "preload: parameter missing. Exiting, to be save..."
		exit 1
	fi
} #}}}

## Showtime ##

checkConfigDir
checkTools

preload "/usr/share/alff/lib/routines"

echo "The ALFF Linux Firewall Framework awakes ..."
echo ""

case "$1" in 
	-h|--help)
		usage
		exit 0
		;;
	-list)
		list_functions
		exit 0
		;;

	generate)
		echo -n  "Cleaning up cache dirs... "
		find "${CACHE_DIR}/chains/" -type f -exec rm {} \;	&& echo -n "chains "
		find "${CACHE_DIR_BUILD}" -type f -exec rm {} \;	&& echo -n "`basename ${CACHE_DIR_BUILD}` "
		echo "done."
		echo ""

		echo "Generation system configuration"
 		configureFirewallNetworkOptions > "${CACHE_DIR_BUILD}/000_proc_options"

		echo "Generating rules... "
		##
		# pimp my "run-parts"
		#
		# Create fd3 (all script should output there stuff to fd3, which is redirected to a proper outfile
		exec 3>&1
		# export environment variables which will be used by the plugins
		export CHAIND_PLUGIN_DIR
		export CACHE_DIR_CHAINS
		find "${CHAIN_D}"  \( -type l -or -type f \) -exec basename {} \; | sort -n | while read plugin; do	
			if [ -x "${CHAIN_D}/${plugin}" ]; then
				sh -c "${CHAIN_D}/${plugin}" 3> "${CACHE_DIR_BUILD}/${plugin}"
			fi
		done

		"$0" loadUserRules 3> "${CACHE_DIR_BUILD}/999_user_rules"

		echo ""
		echo "Generating ruleset... "
		cat "${CACHE_DIR_BUILD}"/* > "${CACHE_DIR}/alff.rules"
		
		;;


	push)
		echo "Pushing the ruleset to your firewalls..."
		echo "To be done..."
		;;

	*)
		if [ $# -gt 0 ]; then
			# try to run former $1
			exec_function ${@}
		else
			usage
		fi
		;;
esac

# vim:ft=sh:foldmethod=marker:
