#!/usr/bin/env sh
#
# fwrbm
#
# Main firewall management tool for the fwrbm firewall fremawork.
#
# Maximlian Wilhelm <mwilhelm@math.uni-paderborn.de>
#  -- Thu, 08 Dec 2005 18:01:52 +0100
#

BASE_DIR="/firewall/current"

FUNCTION_DIR="/usr/share/fwrbm/routines/"

CONFIG_FILE="/etc/fwrbm/fwrbm.conf"
CONFIG_DIR="/etc/fwrbm"
CHAIN_D="${CONFIG_DIR}/chain.d"

MY_NAME="fwrbm"

## Some functions ##

function checkConfigDir() { # Check the configuration (environment) #{{{
	if [ ! -d "${CONFIG_DIR}" ]; then
		echo "Error: CONFIG_DIR \"${CONFIG_DIR}\" does not exist!" >&2
		exit 1
	fi

	if [ ! -d "${CHAIN_D}" ]; then
		echo "Error: CONFIG_DIR \"${CHAIN_D}\" does not exist!" >&2
		exit 1
	fi
} #}}}

function checkTools() { # check for needed tooles #{{{
	for tool in awk bc find grep iptables sh run-parts; do
		if ! command -v ${tool} >/dev/null 2>/dev/null; then
			echo "Error: \"${tool}\" is needed by ${MY_NAME}, but was not found on your system." >&2
		fi
	done
} #}}}

function usage() { # print usage #{{{
	echo "Usage: ${MY_NAME} { -list | start | stop | reload | restart | <function> [ <param> ] }"
	echo ""
	echo "${MY_NAME} is the main firewall management tool."
	echo "It is used for starting, stopping and reloading the firewall rules"
	echo "or add/remove services and reload the configuration after changes."
	echo ""
	echo "We assume that you know what you are doing..."
} #}}}

function list_functions() { # list available functions #{{{
	echo "Functions supported by ${MY_NAME}:"
	find "${FUNCTION_DIR}" -type f -exec basename {} \; | grep -v "^Entries$\|^Root$\|^Repository$" | sed -e 's/^/ * /'
} #}}}

function exec_function() { # execute given function #{{{
	fw_function="${1}"
	if [ -f "${FUNCTION_DIR}/${fw_function}" ]; then
		# shift function name away and keep possbile arguments
		shift
		"${FUNCTION_DIR}/${fw_function}" $@
	else
		echo "Error: Function $1 does not exist." >&2
		echo "Use ${MY_NAME} -list to get a list of all implemented functions"
		exit 1
	fi

} #}}}

# Preload definitions from file (rich mans source) #{{{
function preload()
{
	if [ "${1}" ]; then
		if [ -f ${1} -a -r ${1} ]; then
			source ${1}
			if [ ! $? ]; then
				echo "Failed to preload file \"${1}\", exiting." >&2
				exit 1
			fi
		else
			echo "Unable to preload file \"${1}\". File does not exist or is not accessable, exiting." >&2
			exit 1;
		fi
	else
		echo "preload: parameter missing. Exiting, to be save..."
		exit 1
	fi
} #}}}

## Showtime ##

checkConfigDir
checkTools

preload "/usr/share/fwrbm/lib/routines"

case "$1" in 
	-h|--help)
		usage
		exit 0
		;;
	-list)
		list_functions
		exit 0
		;;

	start|restart)
		echo "${MY_NAME}: Enable the firewall system..."

		# TODO FIXME ConfigCheck in PERL
#		if ! checkConfig; then 
#			echo "Error: Mystic problems in config detected." >&2
#			echo "fwrbm will STOP now to even more avoid trouble..." >&2
#			exit 1
#		fi

		configureFirewallNetworkOptions

		# Set up INPUT before FORWARD as there are be some nasy side effects,
		# if INPUT policy is set to DROP and FORWARD has to be set up.
		# (This should be fixed now, but...)
		# See README.devel for details

		# Create user defined chains and hook them in where they belong to
		# (each script has to do this itself!)
		run-parts "${CHAIN_D}" && echo "done." || echo "FAILED!"

		# Use vlan 114 for ct_sync as it will more or less disable eth1.101
		# if we use eth1.101 for syncing...
#		iptables -A INPUT -p udp -s 131.234.114.41 -d 224.0.0.0/4 -j ACCEPT
#		iptables -A INPUT -p udp -s 131.234.114.42 -d 224.0.0.0/4 -j ACCEPT


		# FORWARD configuration 
#		enableConnTrackFeatures

#		# BRIDGE ONLY
#		acceptUnfilteredTraffic


#		allowCBServicesToInternalNets

	
		"$0" loadUserRules

		;;

	stop)
		echo -n "${MY_NAME}: Disabling the whole firewall system... "
		iptables -P INPUT ACCEPT
		iptables -P FORWARD ACCEPT
		iptables -P OUTPUT ACCEPT
		iptables -F
		iptables -X
		echo "done."
		;;

	reload)
		echo "${MY_NAME}: Reloading services configuration and user rules..."
		"$0" generateAllServiceRules
		"$0" loadUserRules
		;;

	*)
		if [ $# -gt 0 ]; then
			# try to run former $1
			exec_function ${@}
		else
			usage
		fi
		;;
esac

# vim:ft=sh:foldmethod=marker:
