#!/usr/bin/env bash
#
# The Alff Cat
#
# alff Configuration Acceptor Tool
#
# Maximilian Wilhelm <max@rfc2324.org>
#  -- Thu, 25 May 2006 20:56:01 +0200
#

##
# ATTENTION:
# Do never ever add
#       || echo "FAILED!"
# anywhere in this tool, because we want 'set -e' to handle this case!!
#set -e

export LOG_FILE=`tempfile`
export ERROR_LOG=`tempfile`
export MAIL_FILE=`tempfile`
export RULES_DIFF=`tempfile`

# Try to load configuration
if [ -f /etc/alff/alff-agent.conf ]; then
	. /etc/alff/alff-agent.conf
fi

if [ -s /etc/alff/alff-defaults.conf ]; then
	. /etc/alff/alff-defaults.conf
else
	echo "Error: The alff default configuration file does not exist or is empty!" >&2
	exit 1
fi

MY_NAME="alff-cat"

# Check for root privileges
if [ `id -u` != 0 ]; then
	echo "Error: ${MY_NAME} has to be run as root!" >&2
	exit 1
fi

# Check args
if [ -z "${1}" ]; then
	echo "usage: ${MY_NAME} [ - | filename ]" >&2
	exit 1
fi

# Check if rules file is readable, if not reading from stdin
RULES_FILE="${1}"
if [ "${RULES_FILE}" != '-' ]; then
	if [ ! -r "${RULES_FILE}" ]; then
		echo "Error: Rules file ${RULES_FLIE} does not exist or is not readable!" >&2
		exit 1
	fi
fi

# Check for some needed binaries
for tool in tempfile iptables-save iptables-restore; do
	if ! command -v "${tool}" >/dev/null; then
		echo "Error: '${tool}' is required by ${MY_NAME}, but was not found!" >&2
		exit 2
	fi
done

# Create rules backup dir, if not there
if [ ! -d "${RULES_DIR}" ]; then
	mkdir -p "${RULES_DIR}"
fi

function emergency_break() { #{{{
	echo "There occured unkown errors!" >&2
	echo "alff-cat will exit now to prevent future breakage..." >&2
	exit 3
} #}}}

function restore_old_rules() { #{{{
	echo -n "Retoring old ruleset..."
	iptables-restore < "${OLD_RULES_FILE}" && echo "done."
} #}}}

function dump_tables() { # {{{
	for table in ${DIFF_TABLES}; do
		if ! iptables -t ${table} -L -v -n | sed -e 's/^[[:space:]]*[0-9]\+[KMG]\?[[:space:]]\+[0-9]\+[KMG]\?\(.*\)/    0     0\1/' \
							-e 's/[0-9]\+[KMG]\? packets, [0-9]\+[KMG]\? bytes)/0 packets, 0 bytes)/' ; then
			return 1
		fi
	done
} #}}}

# Save the current ruleset to $OLD_RULES_FILE and
# save a zeroed iptables output dump to $OLD_RULES_FILE.iptables
function dump_current_rules() { #{{{

	# Save rules in internal iptables format for case of restore
	if ! iptables-save > "${OLD_RULES_FILE}"; then
		return 1
	fi

	# Save rules in iptables-print-format for possible diff
	if [ "${DIFF_TABLES}" ]; then
		dump_tables > "${OLD_RULES_FILE}.iptables"
	fi
} #}}}

# Usage: send_mail { success, fail, token }
function send_mail() { #{{{

	# Maybe someone does alff-cat to shut up
	if [ "${MAIL_TO}" = 'I_WANT_NO_MAIL' ]; then
		return
	fi

	local SUBJECT=""
	local TEXT=""

	case "${1}" in
		success)
			SUBJECT="New firewall rules successfully loaded on ${HOSTNAME}"
			TEXT="The new ruleset did successfully load on your firewall machine ${HOSTNAME} at `date`."
			;;
		fail)
			SUBJECT="New firewall rules FAILED to load on ${HOSTNAME}"
			TEXT="I'm sorry to tell you that your new firewall rules FAILED to load on your
firewall machines ${HOSTNAME}."
			;;

		token)
			SUBJECT="New firewall rules NOT VERIFIED on ${HOSTNAME}"
			TEXT="I'm sorry to tell you that your new firewall rules were NOT VERIFIED on
your firewall machine ${HOSTAME}.
The old rules have been restored."
			;;
	esac

	cat <<- EOMAILHEADER > "${MAIL_FILE}"
	Hi there!

	$TEXT

	EOMAILHEADER

	# Diff ruleset in iptables format for the admin #{{{
	if [ "${1}" = 'success' -a "${DIFF_TABLES}" ]; then

		dump_tables > "${CURRENT_RULES_FILE}.iptables"

		diff -Nup "${OLD_RULES_FILE}.iptables" "${CURRENT_RULES_FILE}.iptables" > "${RULES_DIFF}"

		if [ -s "${RULES_DIFF}" ]; then
			# Diff of the ruleset
			cat <<- EODIFF >> "${MAIL_FILE}"

			There are some differences:
			================================================================================
			EODIFF

			cat "${RULES_DIFF}" >> "${MAIL_FILE}"

			echo -e "==============================================================================\n" >> "${MAIL_FILE}"
		else
			echo -e "\n There are no differences in the rules. \n" >> "${MAIL_FILE}"
		fi
	fi #}}}

	if [ -s "${LOG_FILE}" ]; then #{{{
		cat <<- EOF >> "${MAIL_FILE}"

		There's something in the logfile (catched from stdout):
		==============================================================================
		EOF

		cat "${LOG_FILE}" >> "${MAIL_FILE}"

		echo -e "==============================================================================\n" >> "${MAIL_FILE}"
	fi #}}}

	if [ -s "${ERROR_LOG}" ]; then #{{{
		cat <<- EOF >> "${MAIL_FILE}"

		There's something in the error log (catched from stderr):
		==============================================================================
		EOF

		cat "${ERROR_LOG}" >> "${MAIL_FILE}"

		echo -e "==============================================================================\n" >> "${MAIL_FILE}"
	fi #}}}

	echo -e "\nYour alff cat." >> "${MAIL_FILE}"

	# Send out the mail
	mail -s "${SUBJECT}" ${MAIL_TO:-root} < "${MAIL_FILE}"
} #}}}

##
# Ok, let´s go

# Dump old rules
echo -n "1"
if dump_current_rules; then
	echo -n "."
else
	echo "FAILED to dump current ruleset!"
	emergency_break
fi

# Save new rules to disk, to keep them over reboot
echo -n " 2"
if cat "${RULES_FILE}" > "${CURRENT_RULES_FILE}"; then
	echo -n "."
else
	echo "FAILED to save new ruleset!"
	emergency_break
fi

# Try to create the delete-me token
echo -n " 3"
if touch "${DELETE_ME_TOKEN}"; then
	echo -n "."
else
	echo "Error: Could not create the delete-me-token!"
	echo ""
	echo "This maybe your last shell on this machine..."
	echo "Use ^Z to put it into the background and try to fix everything."
	echo "You can use 'fg' to come back to here. Then just press <RETURN> to exit."
	echo ""
	echo "Good luck!"
	read
	exit 4
fi

echo -n " 4"
if touch "${RULES_LOADING_TOKEN}"; then
	echo -n "."
else
	echo "Error: Could not create the rules-loading-token!"
	echo ""
	echo "This maybe your last shell on this machine..."
	echo "Use ^Z to put it into the background and try to fix everything."
	echo "You can use 'fg' to come back to here. Then just press <RETURN> to exit."
	echo ""
	echo "Good luck!"
	read
	exit 5
fi

#echo "Will now go to background and load new rules and wait ${SLEEP_TIME:-180} sec. for deletion of the token."
echo -n " ..."

exec < /dev/null 1> "${LOG_FILE}" 2> "${ERROR_LOG}"
(
	STATUS=""

	# Load new rules by just executing the shell script
	if ! sh -e "${CURRENT_RULES_FILE}"; then
		# Something went wrong while loading the new rules
		# Restore the old ones to prevent trouble
		restore_old_rules
		STATUS="fail"
	fi

	# Rule loading has finished.
	# (If the rules did load successfull does not matter here!)
	rm -- "${RULES_LOADING_TOKEN}"

	# If the rules did load without error, try to get them approved
	if [ "${STATUS}" != 'fail' ]; then
		# Wait for deletion of the rules-dont-work-token.
		sleep ${SLEEP_TIME:-180}

		# Chillin' time is over... do we have to do a restore?
		if [ -f "${DELETE_ME_TOKEN}" ]; then
			# Oh, something went wrong... Let´s restore the old rules
			restore_old_rules
			STATUS="token"
		else
			# Yeha, everything went fine
			STATUS="success"
		fi
	fi

	send_mail ${STATUS}

	rm -- "${LOG_FILE}" "${ERROR_LOG}" "${MAIL_FILE}" "${RULES_DIFF}"
) &

# vim:foldmethod=marker
