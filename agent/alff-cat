#!/usr/bin/env sh
#
# The Alff Cat
#
# alff Configuration Acceptor Tool
#
# Maximilian Wilhelm <max@rfc2324.org>
#  -- Thu, 25 May 2006 20:56:01 +0200
#

##
# ATTENTION:
# Do never ever add
#       || echo "FAILED!"
# anywhere in this tool, because we want 'set -e' do handle this case!!
set -e

LOG_FILE=`tempfile`
ERROR_LOG=`tempfile`

# Try to load configuration
if [ -f /etc/alff/alff-agent.conf ]; then
	. /etc/alff/alff-agent.conf
fi

# If there is no config, use defaults
if [ -z "${RULES_DIR}" ]; then
	RULES_DIR="/var/cache/alff/rules"
	OLD_RULES_FILE="${RULES_DIR}/rules.dump"
	CURRENT_RULES_FILE="${RULES_DIR}/rules.current"
	DELETE_ME_FILE="${RULES_DIR}/.current_rules_dont_work"
	SLEEP_TIME=180
fi

MY_NAME="alff-cat"

# Check for root privileges
if [ `id -u` != 0 ]; then
	echo "Error: ${MY_NAME} has to be run as root!" >&2
	exit 1
fi

# Check args
if [ -z "${1}" ]; then
	echo "usage: ${MY_NAME} [ - | filename ]" >&2
	exit 1
fi

# Check if rules file is readable, if not reading from stdin
RULES_FILE="${1}"
if [ "${RULES_FILE}" != '-' ]; then
	if [ ! -r "${RULES_FILE}" ]; then
		echo "Error: Rules file ${RULES_FLIE} does not exist or is not readable!" >&2
		exit 1
	fi
fi

# Check for some needed binaries
for tool in tempfile iptables-save iptables-restore; do
	if ! command -v ${tool} >/dev/null; then
		echo "Error: '${tool}' is required by ${MY_NAME}, but was not found!" >&2
		exit 2
	fi
done

# Create rules backup dir, if not there
if [ ! -d "${RULES_DIR}" ]; then
	mkdir -p "${RULES_DIR}"
fi

function emergency_break() { #{{{
	echo "There occured unkown errors!" >&2
	echo "alff-cat will exit now to prevent future breakage..." >&2
	exit 2
} #}}}

function restore_old_rules() { #{{{
	echo "Retoring old ruleset..."
	iptables-restore < "${OLD_RULES_FILE}" && echo "done."
} #}}}

# Usage: send_mail { success, fail }
function send_mail() { #{{{

	local SUBJECT=""
	local TEXT=""
	local MAIL_FILE=`tempfile`

	case "${1}" in
		success)
			SUBJECT="New firewall rules successfully loaded on ${HOSTNAME}"
			TEXT="The new ruleset did successfully load on your firewall machine ${HOSTNAME}\n at `date`."
			;;
		fail)
			SUBJECT="New firewall rules FAILED to load on ${HOSTNAME}"
			TEXT="I'm sorry to tell you that your new firewall rules FAILED to load on your\n firewall machines ${HOSTNAME}."
			;;

		token)
			SUBJECT="New firewall rules NOT VERIFIED on ${HOSTNAME}"
			TEXT="I'm sorry to tell you that your new firewall rules were NOT VERIFIED on\n your firewall machine ${HOSTAME}.\n The old rules have been restored."
			;;
	esac

cat << EOMAILHEADER > "${MAIL_FILE}"
Hi there!

$TEXT

Here's the logfile:
==============================================================================
EOMAILHEADER

cat < "${LOG_FILE}" >> "${MAIL_FILE}"

cat << EOMAIL >> "${MAIL_FILE}"
==============================================================================

Here's the error log:
==============================================================================
EOMAIL

cat < "${ERROR_LOG}" >> "${MAIL_FILE}"

cat << EOMAILFOOTER >> "${MAIL_FILE}"
==============================================================================

Your alff cat.
EOMAILFOOTER

# Send out the mail to root
mail -s "${SUBJECT}" root < "${MAIL_FILE}"

} #}}}

##
# Ok, let´s go

# Save the current ruleset to $OLD_RULES_FILE
echo "1"
if iptables-save > "${OLD_RULES_FILE}"; then
	echo -n "."
else
	echo "FAILED to dump current ruleset!"
	emergency_break
fi

# Save current rules to disk, to keep them over reboot
echo -n " 2"
if cat "${RULES_FILE}" > "${CURRENT_RULES_FILE}"; then
	echo "."
else
	echo "FAILED to save new ruleset!"
	emergency_break
fi

# Try to create the delete-me token
echo -n " 3"
if touch "${DELETE_ME_FILE}"; then
	echo -n "."
else
	echo "Error: Could not create the delete-me-token!"
	echo ""
	echo "This maybe your last shell on this machine..."
	echo "Use ^Z to put it into the background and try to fix everything."
	echo "You can use 'fg' to come back to here. Then just press <RETURN> to exit."
	echo ""
	echo "Good luck!"
	read
	exit 4
fi

#echo "Will now go to background an load new rules and wait ${SLEEP_TIME:-180} sec. for deletion of the token."
echo -n " ..."

exec < /dev/null 1> "${LOG_FILE}" 2> "${ERROR_LOG}"
(

	# Just execute $CURRENTRULES_FILE
	if ! sh "${CURRENT_RULES_FILE}"; then
		# Something went wrong while loading the new rules
		# Restore the old ones to prevent trouble
		restore_old_rules
		send_mail fail
		exit 3
	fi

	# Wait for deletion of the token.
	sleep ${SLEEP_TIME:-180}

	# Do we have to do a restore?
	if [ -f "${DELETE_ME_FILE}" ]; then
		# Oh, something went wrong... Let´s restore the old rules
		restore_old_rules
		send_mail token
	fi
) &
	
send_mail success

rm "${LOG_FILE}" "${ERROR_LOG}" "${MAIL_FILE}"
# vim:foldmethod=marker
